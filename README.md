# Colloquium-OP

## Коллоквиум по ОС 25.03.2025 | Дрожжа Кирилл Витальевич, 11 Группа, Вариант 2

### Нулевая группа вопросов

1. Для решения лабораторной работы номер 3, связанной с процессами в операционной системе Windows, понадобятся следующие функции из Win32 API:

   - CreateProcess – используется для создания нового процесса. Эта функция запускает новый процесс с заданными параметрами, такими как имя исполняемого файла, командная строка, атрибуты процесса и потока, флаги и т. д. Пример использования:

   ```
    CreateProcess(
        "C:\\ConsoleProcess.exe",   // путь к исполняемому файлу
        NULL,                       // командная строка
        NULL,                       // атрибуты защиты процесса
        NULL,                       // атрибуты защиты потока
        FALSE,                      // флаг наследования дескрипторов
        0,                          // флаги создания процесса
        NULL,                       // переменная среды
        NULL,                       // текущий каталог
        &si,                        // структура STARTUPINFO
        &pi                         // структура PROCESS_INFORMATION
    );
   ```

   - WaitForSingleObject – используется для ожидания завершения процесса или потока. Например, после создания нового процесса, программа может ждать его завершения:

   ```
    WaitForSingleObject(piApp.hProcess, INFINITE);
   ```

   - CloseHandle – закрывает дескриптор процесса или потока:

   ```
    CloseHandle(piApp.hProcess);
    CloseHandle(piApp.hThread);
   ```

   - ExitProcess – используется для завершения процесса. Эта функция вызывает завершение всех потоков, принадлежащих процессу, и освобождает ресурсы:

   ```
    ExitProcess(0);
   ```

2. Поток (thread) в операционной системе Windows — это объект ядра, который представляет собой последовательность исполнения в процессе. Каждый процесс имеет хотя бы один поток, который называется главным потоком. Потоки в процессе могут работать одновременно, что позволяет многозадачным приложениям эффективно использовать ресурсы процессора. Поток имеет свой набор регистров процессора, стек для выполнения, блок окружения и код исполняемой функции.

   В Windows различают два типа потоков:

   - Рабочие потоки (working threads) — выполняют фоновую работу.
   - Потоки интерфейса пользователя (UI threads) — обрабатывают события пользовательского интерфейса.

   Пример создания потока с помощью CreateThread:

   ```
    HANDLE hThread = CreateThread(
        NULL,              // атрибуты защиты потока
        0,                 // размер стека
        ThreadProc,        // функция потока
        NULL,              // параметры для функции
        0,                 // флаги создания потока
        &IDThread          // идентификатор потока
    );
   ```

3. Мьютекс (mutual exclusion) — это объект синхронизации, который используется для предотвращения одновременного доступа к общим ресурсам несколькими потоками. Когда один поток захватывает мьютекс, другие потоки не могут получить к нему доступ, пока он не будет освобожден. Это важно для предотвращения ошибок гонки и для обеспечения правильной работы многозадачных приложений.

   Пример использования мьютекса:

   ```
    HANDLE hMutex = CreateMutex(
        NULL,    // атрибуты безопасности
        FALSE,   // мьютекс не захвачен
        NULL     // имя мьютекса
    );

    // Захват мьютекса
    WaitForSingleObject(hMutex, INFINITE);

    // Работа с общим ресурсом

    // Освобождение мьютекса
    ReleaseMutex(hMutex);

    // Закрытие мьютекса
    CloseHandle(hMutex);
   ```

4. Событие — это объект синхронизации, который используется для сигнализации между потоками. Поток может установить событие в сигнальное состояние, чтобы сообщить другим потокам, что они могут продолжить выполнение. Событие может быть:

   - Сигнальное (Signaled) — когда оно установлено, другие потоки могут продолжить выполнение.
   - Не сигнальное (Non-signaled) — когда оно не установлено, потоки, ожидающие события, блокируются.

   Пример использования события:

   ```
   HANDLE hEvent = CreateEvent(
       NULL,       // атрибуты безопасности
       FALSE,      // не сбрасываемое событие
       FALSE,      // начальное состояние не сигнальное
       NULL        // имя события
   );

   // Ожидание события
   WaitForSingleObject(hEvent, INFINITE);

   // Установить событие в сигнальное состояние
   SetEvent(hEvent);

   // Сбросить событие в не сигнальное состояние
   ResetEvent(hEvent);

   // Закрыть событие
   CloseHandle(hEvent);
   ```

5. - Управление памятью: - В C++98 для работы с динамической памятью использовались только операторы new и delete. В более поздних версиях стандарта (например, C++11) появились умные указатели (std::unique_ptr, std::shared_ptr), которые автоматизируют управление памятью и предотвращают утечки памяти.
   - Многозадачность:
     - В C++98 не было стандартных средств для работы с многозадачностью. В
     - C++11 были добавлены стандартные библиотеки для работы с потоками (std::thread), мьютексами, атомарными операциями и т. д.
   - Лямбда-функции:
     - В C++98 не существовало лямбда-выражений.
     - В C++11 появились лямбда-функции, что сделало код более компактным и удобным, особенно при передаче функций как параметров.
   - Типы данных и авто-вывод:
     - В C++98 типы данных нужно было указывать явно.
     - В C++11 добавилась возможность использовать auto для автоматического вывода типа переменной, что упрощает код.

### Общие вопросы

1. Объектно-ориентированное программирование (ООП) — это методология программирования, основанная на концепции «объектов», которые могут содержать данные в виде полей (иногда называемых атрибутами или свойствами) и код в виде процедур (иногда называемых методами). ООП включает в себя следующие основные принципы:

   - Инкапсуляция — скрытие внутренней реализации объекта и предоставление доступа только через публичные интерфейсы (методы), что обеспечивает защиту данных от неконтролируемого доступа и изменений.
   - Наследование — возможность создания новых классов на основе уже существующих, что позволяет повторно использовать код и расширять функциональность.
   - Полиморфизм — возможность использования одного интерфейса для работы с объектами разных типов. Это позволяет вызвать один и тот же метод для объектов разных классов и получить различное поведение.
   - Абстракция — выделение важных характеристик объекта, исключая несущественные детали. Это позволяет сосредоточиться на значимой функциональности и скрыть сложность системы.

   ООП способствует созданию гибких, расширяемых и поддерживаемых систем, улучшая структурирование и масштабируемость программного кода.

2. Магическое число 7 Миллера — это гипотеза, предложенная психологом Джорджем Миллером, согласно которой человек способен удерживать в своей краткосрочной памяти только 7 ± 2 элемента одновременно. Это число, 7, часто называют «магическим», и оно находит свои применения в различных сферах, в том числе в IT. Вот 7 примеров:

   1. Длина телефонного номера — многие страны используют формат телефонного номера, состоящий из 7 цифр для основной части (например, номер без кода страны или города).
   2. Пароли и кодовые комбинации — традиционно рекомендуется использовать пароли длиной 6-8 символов, так как это оптимально для запоминания человеком.
   3. Человеческая память при работе с данными — при представлении пользователю данных на экране интерфейса часто стараются не показывать более 7 элементов одновременно (например, 7 пунктов в меню).
   4. Меню навигации на веб-страницах — большинство веб-сайтов используют до 7 главных разделов меню, чтобы облегчить восприятие пользователем.
   5. Операции с элементами на экране — интерфейсы часто ограничиваются 7 вариантами выбора (например, количество вкладок в браузере).
   6. Объем «управляемых» потоков данных — при проектировании многозадачных систем часто учитывается способность системы работать с 7 активными потоками данных одновременно, чтобы не перегрузить систему.
   7. Программные интерфейсы и кнопки — часто интерфейсы пользователя включают 7 кнопок для выбора, как это происходит в некоторых мобильных приложениях, чтобы избежать перегрузки экрана.

3. Энтропия ПО относится к мере неопределенности, беспорядка или сложности в программном обеспечении. Системы с высокой энтропией сложны для понимания, изменения и поддержки. Важно учитывать меры, снижающие энтропию ПО, чтобы разработка оставалась предсказуемой и понятной.

   Примеры негативных мер для снижения энтропии ПО (включают элементы, которые делают систему более упорядоченной и контролируемой):

   1. Использование стандартов кодирования — строгие кодовые стандарты и рекомендации помогают уменьшить непредсказуемость и повысить читаемость кода.
   2. Рефакторинг — регулярная переработка и улучшение существующего кода для уменьшения его сложности и повышения поддерживаемости.
   3. Использование шаблонов проектирования — применение шаблонов проектирования, таких как одиночка или фабричный метод, помогает организовать код и сделать его более предсказуемым и масштабируемым.
   4. Автоматизированное тестирование — использование unit-тестов, интеграционных тестов и других автоматических проверок помогает предотвратить ошибки и гарантировать, что изменения не нарушат работу системы.
   5. Документирование кода — подробная документация помогает уменьшить неопределенность и облегчить понимание работы системы другими разработчиками, снижая общий уровень сложности.

4. Признаки сложной системы по Гради Бучу включают:

   1. Большое количество взаимосвязанных компонентов:
      • В примере с многозадачностью, рассмотренном в лабораторных работах, создание и управление потоками (синхронизация потоков) приводит к увеличению взаимосвязей, что делает систему сложной.
      • При проектировании многопоточной программы для выполнения фоновых задач, как в случае с CreateThread в лабораторной работе, количество взаимодействующих потоков и механизмов синхронизации (мьютексы, события) делает систему сложной.
   2. Сложные отношения между объектами:
      • В примере с процессами, созданными с использованием CreateProcess, могут возникать сложности при взаимодействии между родительским и дочерним процессами, так как процессы должны обмениваться данными и управлять своими состояниями.
      • Когда несколько потоков одновременно работают с общими данными в многозадачной среде (например, потоки, использующие общие переменные), возникает сложность в управлении этими состояниями.
   3. Невозможность полной предсказуемости поведения:
      • В случае многозадачного приложения, где используется большое количество потоков, поведение системы может быть непредсказуемым из-за различных состояний потоков (например, блокировки, ожидания).
      • В ситуации с асинхронными задачами или сетевыми запросами, результат зависит от времени отклика, и система может вести себя по-разному.
   4. Высокая степень динамичности:
      • При работе с динамически изменяющимися потоками, например, SuspendThread и ResumeThread, поведение системы зависит от состояния потоков, что делает систему гибкой, но сложной.
      • В многозадачной системе с динамически изменяющимися приоритетами потоков и процессов можно столкнуться с высокой степенью изменения состояния и взаимодействия.
   5. Множество видов интерфейсов для взаимодействия:
      • В примере с CreateThread, где используются различные параметры и интерфейсы для создания потоков, системы с большим количеством интерфейсов становятся сложными для разработки и поддержки.
      • В многозадачной системе с графическим пользовательским интерфейсом и консольными приложениями также необходимо учитывать различные способы взаимодействия (события, потоки, интерфейсы), что увеличивает сложность.

5. Закон иерархических компенсаций Седова гласит, что в эволюции сложных систем компенсация изменений происходит на различных уровнях организации системы. Примеры его применения в IT:
   1. Развитие операционных систем:
      • В начальных версиях операционных систем не было многоуровневой абстракции (например, Windows 98), но с развитием, добавление виртуализации и многозадачности позволило компенсировать ограниченные возможности старых систем.
   2. Разработка языков программирования:
      • Языки, такие как C, C++, и Java, эволюционировали с добавлением новых уровней абстракции (например, объекты и классы в ООП) для компенсации изначальных ограничений, обеспечивая лучшую модульность и поддержку больших проектов.
   3. Многоуровневые базы данных:
      • Развитие реляционных баз данных с добавлением многослойной архитектуры компенсировало ограничения в хранении и извлечении данных. Примером является переход от SQL баз данных к NoSQL для работы с большими данными.
   4. Сетевые протоколы:
      • Развитие интернет-технологий с уровня HTTP/TCP до более сложных решений, таких как WebSockets или GraphQL, компенсирует проблемы с производительностью и возможностью обработки сложных данных в реальном времени.
   5. Разработка мультимедийных систем:
      • С переходом от простых текстовых интерфейсов к многозадачным графическим интерфейсам, IT-индустрия компенсировала дефицит мощности старых ПК, внедряя многозадачные операционные системы и системы с поддержкой 3D-графики и мультимедиа.
